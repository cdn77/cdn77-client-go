// Package cdn77 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package cdn77

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/nullable"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for AccessProtectionType.
const (
	Blocklist AccessProtectionType = "blocklist"
	Disabled  AccessProtectionType = "disabled"
	Passlist  AccessProtectionType = "passlist"
)

// Defines values for AccessType.
const (
	AccessTypeFullAccess AccessType = "full_access"
	AccessTypeNone       AccessType = "none"
	AccessTypeRead       AccessType = "read"
)

// Defines values for AclType.
const (
	AuthenticatedRead AclType = "authenticated-read"
	Private           AclType = "private"
	PublicRead        AclType = "public-read"
	PublicReadWrite   AclType = "public-read-write"
)

// Defines values for ConnectionType.
const (
	Aws           ConnectionType = "aws"
	ObjectStorage ConnectionType = "object-storage"
	Storage       ConnectionType = "storage"
	Url           ConnectionType = "url"
)

// Defines values for ContentDispositionType.
const (
	ContentDispositionTypeNone      ContentDispositionType = "none"
	ContentDispositionTypeParameter ContentDispositionType = "parameter"
)

// Defines values for ContinentCode.
const (
	AF ContinentCode = "AF"
	AQ ContinentCode = "AQ"
	AS ContinentCode = "AS"
	AU ContinentCode = "AU"
	EU ContinentCode = "EU"
	NA ContinentCode = "NA"
	OC ContinentCode = "OC"
	SA ContinentCode = "SA"
)

// Defines values for HttpsRedirectCode.
const (
	N301 HttpsRedirectCode = 301
	N302 HttpsRedirectCode = 302
)

// Defines values for MaxAge.
const (
	MaxAgeN10    MaxAge = 10
	MaxAgeN10800 MaxAge = 10800
	MaxAgeN11520 MaxAge = 11520
	MaxAgeN12960 MaxAge = 12960
	MaxAgeN1440  MaxAge = 1440
	MaxAgeN14400 MaxAge = 14400
	MaxAgeN15840 MaxAge = 15840
	MaxAgeN17280 MaxAge = 17280
	MaxAgeN2160  MaxAge = 2160
	MaxAgeN240   MaxAge = 240
	MaxAgeN2880  MaxAge = 2880
	MaxAgeN30    MaxAge = 30
	MaxAgeN4320  MaxAge = 4320
	MaxAgeN5760  MaxAge = 5760
	MaxAgeN60    MaxAge = 60
	MaxAgeN720   MaxAge = 720
	MaxAgeN7200  MaxAge = 7200
	MaxAgeN8640  MaxAge = 8640
)

// Defines values for MaxAge404.
const (
	MaxAge404N1    MaxAge404 = 1
	MaxAge404N10   MaxAge404 = 10
	MaxAge404N30   MaxAge404 = 30
	MaxAge404N300  MaxAge404 = 300
	MaxAge404N3600 MaxAge404 = 3600
	MaxAge404N5    MaxAge404 = 5
	MaxAge404N60   MaxAge404 = 60
)

// Defines values for ObjectStorageStatsType.
const (
	ObjectCount ObjectStorageStatsType = "object-count"
	Requests    ObjectStorageStatsType = "requests"
	Traffic     ObjectStorageStatsType = "traffic"
	UsedSpace   ObjectStorageStatsType = "used-space"
)

// Defines values for OriginScheme.
const (
	Http  OriginScheme = "http"
	Https OriginScheme = "https"
)

// Defines values for QueryStringIgnoreType.
const (
	QueryStringIgnoreTypeAll  QueryStringIgnoreType = "all"
	QueryStringIgnoreTypeList QueryStringIgnoreType = "list"
	QueryStringIgnoreTypeNone QueryStringIgnoreType = "none"
)

// Defines values for SecureTokenType.
const (
	SecureTokenTypeHighwinds SecureTokenType = "highwinds"
	SecureTokenTypeNone      SecureTokenType = "none"
	SecureTokenTypeParameter SecureTokenType = "parameter"
	SecureTokenTypePath      SecureTokenType = "path"
)

// Defines values for SslType.
const (
	InstantSsl SslType = "instantSsl"
	None       SslType = "none"
	SAN        SslType = "SAN"
	SNI        SslType = "SNI"
)

// AccessProtectionType With "type": "blocklist" all values set are not allowed. With "type": "passlist" only values set are allowed.
type AccessProtectionType string

// AccessType defines model for accessType.
type AccessType string

// AclType defines model for aclType.
type AclType string

// Cache Your files will remain cached for the specified duration, after which your origin will be checked for an updated version of your files. Expiry/cache-control headers override this setting.
type Cache struct {
	// MaxAge In minutes.
	MaxAge *MaxAge `json:"max_age,omitempty"`

	// MaxAge404 In seconds. Use null to set the default value.
	MaxAge404 nullable.Nullable[MaxAge404] `json:"max_age_404,omitempty"`

	// RequestsWithCookiesEnabled When disabled, requests with cookies will ignore changing cookie headers allowing all requests to hit the cache. When enabled, requests with cookies will be handled separately, so when the cookie changes it will not hit the previously cached request with different cookie options.
	RequestsWithCookiesEnabled *bool `json:"requests_with_cookies_enabled,omitempty"`
}

// Cdn defines model for cdn.
type Cdn struct {
	// Cache Your files will remain cached for the specified duration, after which your origin will be checked for an updated version of your files. Expiry/cache-control headers override this setting.
	Cache *Cache `json:"cache,omitempty"`

	// Cnames All CNAMEs should be mapped via DNS to CDN URL. Otherwise it's not possible to generate SSL certificate. Maximum number of CNAMEs is "10".To add more, contact our support.
	Cnames Cnames `json:"cnames"`

	// CreationTime Timestamp when CDN Resource was created.
	CreationTime time.Time `json:"creation_time"`

	// GeoProtection Geo protection enables you to control which countries can access your content directly.
	GeoProtection *GeoProtection `json:"geo_protection,omitempty"`
	Headers       *Headers       `json:"headers,omitempty"`

	// HotlinkProtection Hotlink protection enables you to control which hostnames/domains can link to and access your content directly.
	HotlinkProtection *HotlinkProtection `json:"hotlink_protection,omitempty"`

	// HttpsRedirect If enabled, all requests via HTTP are redirected to HTTPS. Verify HTTPS availability of CNAMEs before activating, if applicable.
	HttpsRedirect *HttpsRedirect `json:"https_redirect,omitempty"`

	// Id ID of the CDN Resource. This is also used as the CDN Resource URL.
	Id int `json:"id"`

	// IpProtection IP protection enables you to control which networks can access your content directly.
	IpProtection *IpProtection `json:"ip_protection,omitempty"`

	// Label The label helps you to identify your CDN Resource.
	Label string `json:"label"`

	// Mp4PseudoStreaming Turn this option on if using a flash-based video player with MP4 files. Pseudo-streaming is used mainly in flash players. HTML5 players use range-requests. When enabled the "query_string" option must be set to ignore all parameters.
	Mp4PseudoStreaming *Mp4PseudoStreaming `json:"mp4_pseudo_streaming,omitempty"`

	// Note Optional note for the CDN Resource.
	Note          nullable.Nullable[string] `json:"note,omitempty"`
	OriginHeaders *OriginHeaders            `json:"origin_headers,omitempty"`

	// OriginId ID of attached Origin (content source for CDN Resource). More information in our <a href="/support/api-docs/v3/origin">Origin</a> API documentation.
	OriginId nullable.Nullable[string] `json:"origin_id,omitempty"`

	// OriginProtection Enabled origin protection can ease the load on your server or even hide it from direct incoming traffic with our proxy servers.
	OriginProtection *OriginProtection `json:"origin_protection,omitempty"`

	// QueryString Enabling this feature will ignore the query string, allowing URLs with <a href="https://en.wikipedia.org/wiki/Query_string">query strings</a> to cache properly. This is particularly useful if you tag your URLs with tracking/marketing parameters, for example.
	QueryString *QueryString `json:"query_string,omitempty"`

	// RateLimit When enabled, this feature limits the data transfer rate by setting "limit_rate" based on the "rs"  URL parameter and "limit_rate_after" by the value from the "ri" URL parameter.
	RateLimit *RateLimit `json:"rate_limit,omitempty"`

	// SecureToken This feature allows you to serve your content using signed URLs. You can enable your users to download secured content from the CDN Resource with a valid hash. Note: When you check this option, make sure to generate secured links to access your content. Maximum length is 64 characters.
	SecureToken *SecureToken `json:"secure_token,omitempty"`
	Ssl         *CdnSsl      `json:"ssl,omitempty"`

	// Stream Detail parameters of stream CDN Resource.
	Stream *StreamSettings `json:"stream,omitempty"`

	// Url URL of the CDN Resource. Automatically generated when the CDN Resource is created. The number is the same as the CDN Resource ID.
	Url string `json:"url"`

	// Waf Protect your website against XSS, SQL injection and more with our SmartWAF. We're using OWASP Core Rule Set (CRS) to protect your data against the most exploited vulnerabilities.
	Waf *Waf `json:"waf,omitempty"`
}

// CdnSsl defines model for cdnSsl.
type CdnSsl struct {
	// SslId ID of the SSL certificate.
	SslId *string `json:"ssl_id,omitempty"`
	Type  SslType `json:"type"`
}

// CdnSummary defines model for cdnSummary.
type CdnSummary struct {
	// Cnames All CNAMEs should be mapped via DNS to CDN URL. Otherwise it's not possible to generate SSL certificate. Maximum number of CNAMEs is "10".To add more, contact our support.
	Cnames Cnames `json:"cnames"`

	// CreationTime Timestamp when CDN Resource was created.
	CreationTime time.Time `json:"creation_time"`

	// Id ID of the CDN Resource. This is also used as the CDN Resource URL.
	Id int `json:"id"`

	// Label The label helps you to identify your CDN Resource.
	Label string `json:"label"`

	// Mp4PseudoStreaming Turn this option on if using a flash-based video player with MP4 files. Pseudo-streaming is used mainly in flash players. HTML5 players use range-requests. When enabled the "query_string" option must be set to ignore all parameters.
	Mp4PseudoStreaming *Mp4PseudoStreaming `json:"mp4_pseudo_streaming,omitempty"`

	// Note Optional note for the CDN Resource.
	Note nullable.Nullable[string] `json:"note,omitempty"`

	// OriginId ID of attached Origin (content source for CDN Resource). More information in our <a href="/support/api-docs/v3/origin">Origin</a> API documentation.
	OriginId nullable.Nullable[string] `json:"origin_id"`

	// Url URL of the CDN Resource. Automatically generated when the CDN Resource is created. The number is the same as the CDN Resource ID.
	Url string `json:"url"`
}

// Cname defines model for cname.
type Cname struct {
	// Cname <a href="https://en.wikipedia.org/wiki/CNAME_record" target="_blank">CNAME</a> assigned to CDN Resource. CNAME should be mapped via DNS to CDN URL. Otherwise it's not possible to generate an SSL certificate for any related CNAME.
	Cname string `json:"cname"`

	// Id ID of CNAME.
	Id string `json:"id"`
}

// Cnames All CNAMEs should be mapped via DNS to CDN URL. Otherwise it's not possible to generate SSL certificate. Maximum number of CNAMEs is "10".To add more, contact our support.
type Cnames = []Cname

// ConnectionType defines model for connectionType.
type ConnectionType string

// ContentDisposition When the "type" is set to "parameter" the Content-Disposition is defined by the "cd" parameter in the URL, often set to "attachment". The filename is specified using the "fn" parameter in the URL.
type ContentDisposition struct {
	Type *ContentDispositionType `json:"type,omitempty"`
}

// ContentDispositionType defines model for contentDispositionType.
type ContentDispositionType string

// ContinentCode We recognize 8 continents specified with two letter Continent code.
type ContinentCode string

// EditSsl defines model for editSsl.
type EditSsl struct {
	// Certificate SNI certificate.
	Certificate string `json:"certificate"`

	// PrivateKey Private key of the SSL certificate.
	PrivateKey *string `json:"private_key,omitempty"`
}

// Errors defines model for errors.
type Errors struct {
	Errors []string `json:"errors"`
	Type   *string  `json:"type,omitempty"`
}

// FieldErrors defines model for fieldErrors.
type FieldErrors struct {
	Errors []string            `json:"errors"`
	Fields map[string][]string `json:"fields"`
}

// GeoProtection Geo protection enables you to control which countries can access your content directly.
type GeoProtection struct {
	// Countries We are using ISO 3166-1 alpha-2 code. For full list check <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements" target="_blank">Wikipedia</a>.
	Countries *[]string `json:"countries,omitempty"`

	// Type With "type": "blocklist" all values set are not allowed. With "type": "passlist" only values set are allowed.
	Type AccessProtectionType `json:"type"`
}

// GetObjectStorageStats defines model for getObjectStorageStats.
type GetObjectStorageStats struct {
	Aggregation string    `json:"aggregation"`
	Buckets     *[]string `json:"buckets,omitempty"`
	From        int       `json:"from"`
	To          int       `json:"to"`
}

// Headers defines model for headers.
type Headers struct {
	// ContentDisposition When the "type" is set to "parameter" the Content-Disposition is defined by the "cd" parameter in the URL, often set to "attachment". The filename is specified using the "fn" parameter in the URL.
	ContentDisposition *ContentDisposition `json:"content_disposition,omitempty"`

	// CorsEnabled The "Access-Control-Allow-Origin:" response header will always act in accordance with the "Origin:" request header sent by the client. For example, a request including the HTTP header "Origin: https://www.cdn77.com" will translate to the response header "Access-Control-Allow-Origin: https://www.cdn77.com". Files remain cached while the request/response header changes.
	CorsEnabled *bool `json:"cors_enabled,omitempty"`

	// CorsTimingEnabled When enabled "Timing-Allow-Origin" CORS header is set.
	CorsTimingEnabled *bool `json:"cors_timing_enabled,omitempty"`

	// CorsWildcardEnabled When enabled the wildcard value (*) is set in CORS headers.
	CorsWildcardEnabled *bool `json:"cors_wildcard_enabled,omitempty"`

	// HostHeaderForwardingEnabled When fetching the content from the origin server, our edge servers will pass the host header that was included in the request between the user and our edge server.
	HostHeaderForwardingEnabled *bool `json:"host_header_forwarding_enabled,omitempty"`
}

// HotlinkProtection Hotlink protection enables you to control which hostnames/domains can link to and access your content directly.
type HotlinkProtection struct {
	Domains *[]string `json:"domains,omitempty"`

	// EmptyRefererDenied Enabling this parameter prevents your content from being directly accessed by sources that send empty referrers.
	EmptyRefererDenied bool `json:"empty_referer_denied"`

	// Type With "type": "blocklist" all values set are not allowed. With "type": "passlist" only values set are allowed.
	Type AccessProtectionType `json:"type"`
}

// HttpsRedirect If enabled, all requests via HTTP are redirected to HTTPS. Verify HTTPS availability of CNAMEs before activating, if applicable.
type HttpsRedirect struct {
	// Code 301 for permanent redirect and 302 for temporary redirect. If you are not sure, select the default 301 code.
	Code    *HttpsRedirectCode `json:"code,omitempty"`
	Enabled bool               `json:"enabled"`
}

// HttpsRedirectCode 301 for permanent redirect and 302 for temporary redirect. If you are not sure, select the default 301 code.
type HttpsRedirectCode int

// IpProtection IP protection enables you to control which networks can access your content directly.
type IpProtection struct {
	Ips *[]string `json:"ips,omitempty"`

	// Type With "type": "blocklist" all values set are not allowed. With "type": "passlist" only values set are allowed.
	Type AccessProtectionType `json:"type"`
}

// MaxAge In minutes.
type MaxAge int

// MaxAge404 In seconds. Use null to set the default value.
type MaxAge404 int

// Mp4PseudoStreaming Turn this option on if using a flash-based video player with MP4 files. Pseudo-streaming is used mainly in flash players. HTML5 players use range-requests. When enabled the "query_string" option must be set to ignore all parameters.
type Mp4PseudoStreaming struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// NewSsl defines model for newSsl.
type NewSsl struct {
	// Certificate SNI certificate.
	Certificate string `json:"certificate"`

	// PrivateKey Private key of the SSL certificate.
	PrivateKey string `json:"private_key"`
}

// ObjectStorageCluster defines model for objectStorageCluster.
type ObjectStorageCluster struct {
	Host   string `json:"host"`
	Id     string `json:"id"`
	Label  string `json:"label"`
	Port   *int   `json:"port,omitempty"`
	Scheme string `json:"scheme"`
}

// ObjectStorageClusters defines model for objectStorageClusters.
type ObjectStorageClusters = []ObjectStorageCluster

// ObjectStorageOriginDetail CDN77 Object Storage Origin detail
type ObjectStorageOriginDetail struct {
	// AccessKeyId Access key to your bucket.
	AccessKeyId *string `json:"access_key_id,omitempty"`

	// AccessSecret Access secret to your bucket.
	AccessSecret *string `json:"access_secret,omitempty"`

	// BucketName Name of your bucket.
	BucketName string `json:"bucket_name"`

	// Cdns List of all CDN Resources assigned to the Origin.
	Cdns      []OriginCdn `json:"cdns"`
	CreatedAt time.Time   `json:"created_at"`

	// Host Origin host without scheme and port.
	Host string `json:"host"`

	// Id Origin ID.
	Id string `json:"id"`

	// Label Origin label.
	Label string `json:"label"`

	// Note Optional note for the Origin.
	Note nullable.Nullable[string] `json:"note,omitempty"`

	// Port Origin port. If not specified, the default scheme port is used. Allowed range is between 1 and 65535.
	Port   nullable.Nullable[int] `json:"port,omitempty"`
	Scheme OriginScheme           `json:"scheme"`
	Type   ConnectionType         `json:"type"`
	Usage  ObjectStorageUsage     `json:"usage"`
}

// ObjectStorageStats defines model for objectStorageStats.
type ObjectStorageStats struct {
	Timestamp int     `json:"timestamp"`
	Value     float32 `json:"value"`
}

// ObjectStorageStatsSet defines model for objectStorageStatsSet.
type ObjectStorageStatsSet struct {
	Stats *[]ObjectStorageStats `json:"stats,omitempty"`
}

// ObjectStorageStatsType defines model for objectStorageStatsType.
type ObjectStorageStatsType string

// ObjectStorageUsage defines model for objectStorageUsage.
type ObjectStorageUsage struct {
	FileCount *int `json:"file_count,omitempty"`
	SizeBytes *int `json:"size_bytes,omitempty"`
}

// OriginCdn defines model for originCdn.
type OriginCdn struct {
	// Id ID of the CDN Resource. This is also used as the CDN Resource URL.
	Id int `json:"id"`

	// Label The label helps you to identify your CDN Resource.
	Label string `json:"label"`
}

// OriginHeaders defines model for originHeaders.
type OriginHeaders struct {
	// Custom Custom HTTP headers included in requests sent to the origin server.
	Custom nullable.Nullable[map[string]string] `json:"custom,omitempty"`
}

// OriginList defines model for originList.
type OriginList = []OriginList_Item

// OriginProtection Enabled origin protection can ease the load on your server or even hide it from direct incoming traffic with our proxy servers.
type OriginProtection struct {
	Enabled bool `json:"enabled"`
}

// OriginScheme defines model for originScheme.
type OriginScheme string

// QueryString Enabling this feature will ignore the query string, allowing URLs with <a href="https://en.wikipedia.org/wiki/Query_string">query strings</a> to cache properly. This is particularly useful if you tag your URLs with tracking/marketing parameters, for example.
type QueryString struct {
	IgnoreType QueryStringIgnoreType `json:"ignore_type"`

	// Parameters List of parameters used when "ignore_type" is set to "list".
	Parameters *[]string `json:"parameters,omitempty"`
}

// QueryStringIgnoreType defines model for queryStringIgnoreType.
type QueryStringIgnoreType string

// RateLimit When enabled, this feature limits the data transfer rate by setting "limit_rate" based on the "rs"  URL parameter and "limit_rate_after" by the value from the "ri" URL parameter.
type RateLimit struct {
	Enabled bool `json:"enabled"`
}

// S3OriginDetail S3 Origin detail
type S3OriginDetail struct {
	// AwsAccessKeyId Located in the Security Credentials section of your AWS account.
	AwsAccessKeyId nullable.Nullable[string] `json:"aws_access_key_id,omitempty"`

	// AwsRegion Located in the Security Credentials section of your AWS account. Possibly stored as AWS_DEFAULT_REGION.
	AwsRegion nullable.Nullable[string] `json:"aws_region,omitempty"`

	// BaseDir Directory of the stored content on your AWS Origin. Maximum length is 255 characters.
	BaseDir nullable.Nullable[string] `json:"base_dir,omitempty"`

	// Cdns List of all CDN Resources assigned to the Origin.
	Cdns []OriginCdn `json:"cdns"`

	// Host AWS Origin host without scheme and port. Can be a domain name or an IP address.
	Host string `json:"host"`

	// Id Origin ID.
	Id string `json:"id"`

	// Label Origin label.
	Label string `json:"label"`

	// Note Optional note for the Origin.
	Note nullable.Nullable[string] `json:"note,omitempty"`

	// Port AWS Origin port. If not specified, the default scheme port is used. Allowed range is between 1 and 65535.
	Port   nullable.Nullable[int] `json:"port,omitempty"`
	Scheme OriginScheme           `json:"scheme"`
	Type   ConnectionType         `json:"type"`
}

// SecureToken This feature allows you to serve your content using signed URLs. You can enable your users to download secured content from the CDN Resource with a valid hash. Note: When you check this option, make sure to generate secured links to access your content. Maximum length is 64 characters.
type SecureToken struct {
	// Token Token length is between 8 and 64 characters.
	Token *string `json:"token,omitempty"`

	// Type  <ol>
	//         <li>parameter - Token will be in the query string - e.g.:/video.mp4?secure=MY_SECURE_TOKEN.</li>
	//         <li>path - Token will be in the path - e.g.:/MY_SECURE_TOKEN/video.mp4.</li>
	//         <li>none - Use to disable secure token.</li>
	//         <li>highwinds</li>
	// </ol>
	Type SecureTokenType `json:"type"`
}

// SecureTokenType  <ol>
//
//	<li>parameter - Token will be in the query string - e.g.:/video.mp4?secure=MY_SECURE_TOKEN.</li>
//	<li>path - Token will be in the path - e.g.:/MY_SECURE_TOKEN/video.mp4.</li>
//	<li>none - Use to disable secure token.</li>
//	<li>highwinds</li>
//
// </ol>
type SecureTokenType string

// Ssl defines model for ssl.
type Ssl struct {
	AssignedResources []SslCdn `json:"assigned_resources"`

	// Certificate SNI certificate.
	Certificate string `json:"certificate"`

	// Cnames <a href="https://en.wikipedia.org/wiki/CNAME_record" target="_blank">CNAMEs</a> assigned to SNI certificate.
	Cnames []string `json:"cnames"`

	// ExpiresAt Date and time of the SNI certificate expiration.
	ExpiresAt time.Time `json:"expires_at"`

	// Id ID of the SSL certificate.
	Id string `json:"id"`
}

// SslCdn defines model for sslCdn.
type SslCdn struct {
	// Id ID of the CDN Resource. This is also used as the CDN Resource URL.
	Id int `json:"id"`

	// Label The label helps you to identify your CDN Resource.
	Label string `json:"label"`
}

// SslList defines model for sslList.
type SslList = []Ssl

// SslType defines model for sslType.
type SslType string

// StorageLocationSchema Location of the CDN77 Storage server.
type StorageLocationSchema struct {
	Id       *string `json:"id,omitempty"`
	Location *string `json:"location,omitempty"`
}

// StorageOriginDetail CDN77 Storage Origin detail
type StorageOriginDetail struct {
	// Cdns List of all CDN Resources assigned to the Origin.
	Cdns []OriginCdn `json:"cdns"`

	// Id Origin ID.
	Id string `json:"id"`

	// Label Origin label.
	Label string `json:"label"`

	// Note Optional note for the Origin.
	Note   nullable.Nullable[string] `json:"note,omitempty"`
	Scheme OriginScheme              `json:"scheme"`

	// Server Location of the CDN77 Storage server.
	Server StorageLocationSchema `json:"server"`
	Type   ConnectionType        `json:"type"`
	Usage  UsageDetailSchema     `json:"usage"`
}

// StreamSettings Detail parameters of stream CDN Resource.
type StreamSettings struct {
	OriginUrl string  `json:"origin_url"`
	Password  *string `json:"password,omitempty"`
	Path      *string `json:"path,omitempty"`
	Port      int     `json:"port"`
	Protocol  string  `json:"protocol"`
	QueryKey  string  `json:"query_key"`
}

// UrlOriginDetail URL Origin detail
type UrlOriginDetail struct {
	// BaseDir Directory where the content is stored on the URL Origin. Maximum length is 255.
	BaseDir nullable.Nullable[string] `json:"base_dir,omitempty"`

	// Cdns List of all CDN Resources assigned to the Origin.
	Cdns []OriginCdn `json:"cdns"`

	// Host Origin URL host without scheme and port. Can be a domain name or an IP address.
	Host string `json:"host"`

	// Id Origin ID.
	Id string `json:"id"`

	// Label Origin label.
	Label string `json:"label"`

	// Note Optional note for the Origin.
	Note nullable.Nullable[string] `json:"note,omitempty"`

	// Port Origin URL port. If not specified, the default scheme port is used. Allowed range is between 1 and 65535.
	Port   nullable.Nullable[int] `json:"port,omitempty"`
	Scheme OriginScheme           `json:"scheme"`
	Type   ConnectionType         `json:"type"`
}

// UsageDetailSchema defines model for usageDetailSchema.
type UsageDetailSchema struct {
	// Nodes The number of files on the CDN77 Storage.
	Nodes *int `json:"nodes,omitempty"`

	// Space CDN77 Storage space used in bytes.
	Space *int       `json:"space,omitempty"`
	Time  *time.Time `json:"time,omitempty"`
}

// Waf Protect your website against XSS, SQL injection and more with our SmartWAF. We're using OWASP Core Rule Set (CRS) to protect your data against the most exploited vulnerabilities.
type Waf struct {
	Enabled bool `json:"enabled"`
}

// OriginList_Item defines model for originList.Item.
type OriginList_Item struct {
	union json.RawMessage
}

// CdnAddJSONBody defines parameters for CdnAdd.
type CdnAddJSONBody struct {
	// Cnames All CNAMEs should be mapped via DNS to CDN URL. Otherwise it's not possible to generate SSL certificate. Maximum number of CNAMEs is "10". To add more, contact our support.
	Cnames *[]string `json:"cnames,omitempty"`

	// Label The label helps you to identify your CDN Resource.
	Label string `json:"label"`

	// Note Optional note for the CDN Resource.
	Note nullable.Nullable[string] `json:"note,omitempty"`

	// OriginId ID of attached Origin (content source for CDN Resource). More information in our <a href="/support/api-docs/v3/origin">Origin</a> API documentation.
	OriginId string `json:"origin_id"`
}

// CdnEditJSONBody defines parameters for CdnEdit.
type CdnEditJSONBody struct {
	// Cache Your files will remain cached for the specified duration, after which your origin will be checked for an updated version of your files. Expiry/cache-control headers override this setting.
	Cache *Cache `json:"cache,omitempty"`

	// Cnames All CNAMEs should be mapped via DNS to CDN URL. Otherwise it's not possible to generate SSL certificate.Maximum number of CNAMEs is "10". To add more, contact our support.
	Cnames *[]string `json:"cnames,omitempty"`

	// GeoProtection Geo protection enables you to control which countries can access your content directly.
	GeoProtection *GeoProtection `json:"geo_protection,omitempty"`
	Headers       *Headers       `json:"headers,omitempty"`

	// HotlinkProtection Hotlink protection enables you to control which hostnames/domains can link to and access your content directly.
	HotlinkProtection *HotlinkProtection `json:"hotlink_protection,omitempty"`

	// HttpsRedirect If enabled, all requests via HTTP are redirected to HTTPS. Verify HTTPS availability of CNAMEs before activating, if applicable.
	HttpsRedirect *HttpsRedirect `json:"https_redirect,omitempty"`

	// IpProtection IP protection enables you to control which networks can access your content directly.
	IpProtection *IpProtection `json:"ip_protection,omitempty"`

	// Label The label helps you to identify your CDN Resource.
	Label *string `json:"label,omitempty"`

	// Mp4PseudoStreaming Turn this option on if using a flash-based video player with MP4 files. Pseudo-streaming is used mainly in flash players. HTML5 players use range-requests. When enabled the "query_string" option must be set to ignore all parameters.
	Mp4PseudoStreaming *Mp4PseudoStreaming `json:"mp4_pseudo_streaming,omitempty"`

	// Note Optional note for the CDN Resource.
	Note          nullable.Nullable[string] `json:"note,omitempty"`
	OriginHeaders *OriginHeaders            `json:"origin_headers,omitempty"`

	// OriginId ID of attached Origin (content source for CDN Resource). More information in our <a href="/support/api-docs/v3/origin">Origin</a> API documentation.
	OriginId *string `json:"origin_id,omitempty"`

	// QueryString Enabling this feature will ignore the query string, allowing URLs with <a href="https://en.wikipedia.org/wiki/Query_string">query strings</a> to cache properly. This is particularly useful if you tag your URLs with tracking/marketing parameters, for example.
	QueryString *QueryString `json:"query_string,omitempty"`

	// RateLimit When enabled, this feature limits the data transfer rate by setting "limit_rate" based on the "rs"  URL parameter and "limit_rate_after" by the value from the "ri" URL parameter.
	RateLimit *RateLimit `json:"rate_limit,omitempty"`

	// SecureToken This feature allows you to serve your content using signed URLs. You can enable your users to download secured content from the CDN Resource with a valid hash. Note: When you check this option, make sure to generate secured links to access your content. Maximum length is 64 characters.
	SecureToken *SecureToken `json:"secure_token,omitempty"`
	Ssl         *CdnSsl      `json:"ssl,omitempty"`

	// Waf Protect your website against XSS, SQL injection and more with our SmartWAF. We're using OWASP Core Rule Set (CRS) to protect your data against the most exploited vulnerabilities.
	Waf *Waf `json:"waf,omitempty"`
}

// CnameAddJSONBody defines parameters for CnameAdd.
type CnameAddJSONBody struct {
	// Cname <a href="https://en.wikipedia.org/wiki/CNAME_record" target="_blank">CNAME</a> should be mapped via DNS to CDN URL. Otherwise it's not possible to generate SSL certificate for any CNAME assigned to CDN Resource.
	Cname string `json:"cname"`
}

// CdnDatacentersEnableJSONBody defines parameters for CdnDatacentersEnable.
type CdnDatacentersEnableJSONBody = []openapi_types.UUID

// OriginAddAwsJSONBody defines parameters for OriginAddAws.
type OriginAddAwsJSONBody struct {
	// AwsAccessKeyId Located in the Security Credentials section of your AWS account.
	AwsAccessKeyId nullable.Nullable[string] `json:"aws_access_key_id,omitempty"`

	// AwsAccessKeySecret Located in the Security Credentials section of your AWS account.
	AwsAccessKeySecret nullable.Nullable[string] `json:"aws_access_key_secret,omitempty"`

	// AwsRegion Located in the Security Credentials section of your AWS account. Possibly stored as AWS_DEFAULT_REGION.
	AwsRegion nullable.Nullable[string] `json:"aws_region,omitempty"`

	// BaseDir Directory of the stored content on your AWS Origin. Maximum length is 255. characters
	BaseDir nullable.Nullable[string] `json:"base_dir,omitempty"`

	// Host AWS Origin host without scheme and port. Can be a domain name or an IP address.
	Host string `json:"host"`

	// Label The label helps you to identify your AWS Origin.
	Label string `json:"label"`

	// Note Optional note for the Origin.
	Note nullable.Nullable[string] `json:"note,omitempty"`

	// Port AWS Origin port. If not specified, the default scheme port is used. Allowed range is between 1 and 65535.
	Port   nullable.Nullable[int] `json:"port,omitempty"`
	Scheme OriginScheme           `json:"scheme"`
}

// OriginEditAwsJSONBody defines parameters for OriginEditAws.
type OriginEditAwsJSONBody struct {
	AwsAccessKeyId     nullable.Nullable[string] `json:"aws_access_key_id,omitempty"`
	AwsAccessKeySecret nullable.Nullable[string] `json:"aws_access_key_secret,omitempty"`
	AwsRegion          nullable.Nullable[string] `json:"aws_region,omitempty"`
	BaseDir            nullable.Nullable[string] `json:"base_dir,omitempty"`
	Host               *string                   `json:"host,omitempty"`
	Label              *string                   `json:"label,omitempty"`

	// Note Optional note for the Origin.
	Note   nullable.Nullable[string] `json:"note,omitempty"`
	Port   nullable.Nullable[int]    `json:"port,omitempty"`
	Scheme *string                   `json:"scheme,omitempty"`
}

// OriginAddObjectStorageJSONBody defines parameters for OriginAddObjectStorage.
type OriginAddObjectStorageJSONBody struct {
	Acl        AclType `json:"acl"`
	BucketName string  `json:"bucket_name"`

	// ClusterId Cluster ID
	ClusterId string                    `json:"cluster_id"`
	Label     string                    `json:"label"`
	Note      nullable.Nullable[string] `json:"note,omitempty"`
}

// OriginEditObjectStorageJSONBody defines parameters for OriginEditObjectStorage.
type OriginEditObjectStorageJSONBody struct {
	AccessKeys *[]struct {
		// AccessKeyId Access key ID
		AccessKeyId *string     `json:"access_key_id,omitempty"`
		Type        *AccessType `json:"type,omitempty"`
	} `json:"access_keys,omitempty"`
	Label *string                   `json:"label,omitempty"`
	Note  nullable.Nullable[string] `json:"note,omitempty"`
}

// OriginEditStorageJSONBody defines parameters for OriginEditStorage.
type OriginEditStorageJSONBody struct {
	Label *string `json:"label,omitempty"`

	// Note Optional note for the Origin.
	Note     nullable.Nullable[string] `json:"note,omitempty"`
	Password *string                   `json:"password,omitempty"`
}

// OriginAddUrlJSONBody defines parameters for OriginAddUrl.
type OriginAddUrlJSONBody struct {
	// BaseDir Directory where the content is stored on the URL Origin. It must not end with the slash. Maximum length is 255.
	BaseDir nullable.Nullable[string] `json:"base_dir,omitempty"`

	// Host URL Origin host without scheme and port. Can be domain name or IP address.
	Host string `json:"host"`

	// Label The label helps you to identify your URL Origin.
	Label string `json:"label"`

	// Note Optional note for the Origin.
	Note nullable.Nullable[string] `json:"note,omitempty"`

	// Port URL Origin port. If not specified, default scheme port is used. Allowed range is between 1 and 65535.
	Port   nullable.Nullable[int] `json:"port,omitempty"`
	Scheme OriginScheme           `json:"scheme"`
}

// OriginEditUrlJSONBody defines parameters for OriginEditUrl.
type OriginEditUrlJSONBody struct {
	BaseDir nullable.Nullable[string] `json:"base_dir,omitempty"`
	Host    *string                   `json:"host,omitempty"`
	Label   *string                   `json:"label,omitempty"`

	// Note Optional note for the Origin.
	Note   nullable.Nullable[string] `json:"note,omitempty"`
	Port   nullable.Nullable[int]    `json:"port,omitempty"`
	Scheme *string                   `json:"scheme,omitempty"`
}

// CdnAddJSONRequestBody defines body for CdnAdd for application/json ContentType.
type CdnAddJSONRequestBody CdnAddJSONBody

// CdnEditJSONRequestBody defines body for CdnEdit for application/json ContentType.
type CdnEditJSONRequestBody CdnEditJSONBody

// CnameAddJSONRequestBody defines body for CnameAdd for application/json ContentType.
type CnameAddJSONRequestBody CnameAddJSONBody

// CdnDatacentersEnableJSONRequestBody defines body for CdnDatacentersEnable for application/json ContentType.
type CdnDatacentersEnableJSONRequestBody = CdnDatacentersEnableJSONBody

// ObjectStorageStatsJSONRequestBody defines body for ObjectStorageStats for application/json ContentType.
type ObjectStorageStatsJSONRequestBody = GetObjectStorageStats

// OriginAddAwsJSONRequestBody defines body for OriginAddAws for application/json ContentType.
type OriginAddAwsJSONRequestBody OriginAddAwsJSONBody

// OriginEditAwsJSONRequestBody defines body for OriginEditAws for application/json ContentType.
type OriginEditAwsJSONRequestBody OriginEditAwsJSONBody

// OriginAddObjectStorageJSONRequestBody defines body for OriginAddObjectStorage for application/json ContentType.
type OriginAddObjectStorageJSONRequestBody OriginAddObjectStorageJSONBody

// OriginEditObjectStorageJSONRequestBody defines body for OriginEditObjectStorage for application/json ContentType.
type OriginEditObjectStorageJSONRequestBody OriginEditObjectStorageJSONBody

// OriginEditStorageJSONRequestBody defines body for OriginEditStorage for application/json ContentType.
type OriginEditStorageJSONRequestBody OriginEditStorageJSONBody

// OriginAddUrlJSONRequestBody defines body for OriginAddUrl for application/json ContentType.
type OriginAddUrlJSONRequestBody OriginAddUrlJSONBody

// OriginEditUrlJSONRequestBody defines body for OriginEditUrl for application/json ContentType.
type OriginEditUrlJSONRequestBody OriginEditUrlJSONBody

// SslSniAddJSONRequestBody defines body for SslSniAdd for application/json ContentType.
type SslSniAddJSONRequestBody = NewSsl

// SslSniEditJSONRequestBody defines body for SslSniEdit for application/json ContentType.
type SslSniEditJSONRequestBody = EditSsl

// AsObjectStorageOriginDetail returns the union data inside the OriginList_Item as a ObjectStorageOriginDetail
func (t OriginList_Item) AsObjectStorageOriginDetail() (ObjectStorageOriginDetail, error) {
	var body ObjectStorageOriginDetail
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObjectStorageOriginDetail overwrites any union data inside the OriginList_Item as the provided ObjectStorageOriginDetail
func (t *OriginList_Item) FromObjectStorageOriginDetail(v ObjectStorageOriginDetail) error {
	v.Type = "object-storage"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObjectStorageOriginDetail performs a merge with any union data inside the OriginList_Item, using the provided ObjectStorageOriginDetail
func (t *OriginList_Item) MergeObjectStorageOriginDetail(v ObjectStorageOriginDetail) error {
	v.Type = "object-storage"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStorageOriginDetail returns the union data inside the OriginList_Item as a StorageOriginDetail
func (t OriginList_Item) AsStorageOriginDetail() (StorageOriginDetail, error) {
	var body StorageOriginDetail
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStorageOriginDetail overwrites any union data inside the OriginList_Item as the provided StorageOriginDetail
func (t *OriginList_Item) FromStorageOriginDetail(v StorageOriginDetail) error {
	v.Type = "storage"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStorageOriginDetail performs a merge with any union data inside the OriginList_Item, using the provided StorageOriginDetail
func (t *OriginList_Item) MergeStorageOriginDetail(v StorageOriginDetail) error {
	v.Type = "storage"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsS3OriginDetail returns the union data inside the OriginList_Item as a S3OriginDetail
func (t OriginList_Item) AsS3OriginDetail() (S3OriginDetail, error) {
	var body S3OriginDetail
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromS3OriginDetail overwrites any union data inside the OriginList_Item as the provided S3OriginDetail
func (t *OriginList_Item) FromS3OriginDetail(v S3OriginDetail) error {
	v.Type = "aws"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeS3OriginDetail performs a merge with any union data inside the OriginList_Item, using the provided S3OriginDetail
func (t *OriginList_Item) MergeS3OriginDetail(v S3OriginDetail) error {
	v.Type = "aws"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUrlOriginDetail returns the union data inside the OriginList_Item as a UrlOriginDetail
func (t OriginList_Item) AsUrlOriginDetail() (UrlOriginDetail, error) {
	var body UrlOriginDetail
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUrlOriginDetail overwrites any union data inside the OriginList_Item as the provided UrlOriginDetail
func (t *OriginList_Item) FromUrlOriginDetail(v UrlOriginDetail) error {
	v.Type = "url"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUrlOriginDetail performs a merge with any union data inside the OriginList_Item, using the provided UrlOriginDetail
func (t *OriginList_Item) MergeUrlOriginDetail(v UrlOriginDetail) error {
	v.Type = "url"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OriginList_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OriginList_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "aws":
		return t.AsS3OriginDetail()
	case "object-storage":
		return t.AsObjectStorageOriginDetail()
	case "storage":
		return t.AsStorageOriginDetail()
	case "url":
		return t.AsUrlOriginDetail()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OriginList_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OriginList_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CdnList request
	CdnList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CdnAddWithBody request with any body
	CdnAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CdnAdd(ctx context.Context, body CdnAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CdnDelete request
	CdnDelete(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CdnDetail request
	CdnDetail(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CdnEditWithBody request with any body
	CdnEditWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CdnEdit(ctx context.Context, id int, body CdnEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CnameList request
	CnameList(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CnameAddWithBody request with any body
	CnameAddWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CnameAdd(ctx context.Context, id int, body CnameAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CdnDatacentersList request
	CdnDatacentersList(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CdnDatacentersEnableWithBody request with any body
	CdnDatacentersEnableWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CdnDatacentersEnable(ctx context.Context, id int, body CdnDatacentersEnableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObjectStorageClusterList request
	ObjectStorageClusterList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObjectStorageStatsWithBody request with any body
	ObjectStorageStatsWithBody(ctx context.Context, pType ObjectStorageStatsType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ObjectStorageStats(ctx context.Context, pType ObjectStorageStatsType, body ObjectStorageStatsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginList request
	OriginList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginAddAwsWithBody request with any body
	OriginAddAwsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OriginAddAws(ctx context.Context, body OriginAddAwsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginDeleteAws request
	OriginDeleteAws(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginDetailAws request
	OriginDetailAws(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginEditAwsWithBody request with any body
	OriginEditAwsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OriginEditAws(ctx context.Context, id string, body OriginEditAwsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginAddObjectStorageWithBody request with any body
	OriginAddObjectStorageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OriginAddObjectStorage(ctx context.Context, body OriginAddObjectStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginDeleteObjectStorage request
	OriginDeleteObjectStorage(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginDetailObjectStorage request
	OriginDetailObjectStorage(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginEditObjectStorageWithBody request with any body
	OriginEditObjectStorageWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OriginEditObjectStorage(ctx context.Context, id string, body OriginEditObjectStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginDeleteStorage request
	OriginDeleteStorage(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginDetailStorage request
	OriginDetailStorage(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginEditStorageWithBody request with any body
	OriginEditStorageWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OriginEditStorage(ctx context.Context, id string, body OriginEditStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginAddUrlWithBody request with any body
	OriginAddUrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OriginAddUrl(ctx context.Context, body OriginAddUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginDeleteUrl request
	OriginDeleteUrl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginDetailUrl request
	OriginDetailUrl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OriginEditUrlWithBody request with any body
	OriginEditUrlWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OriginEditUrl(ctx context.Context, id string, body OriginEditUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SslSniList request
	SslSniList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SslSniAddWithBody request with any body
	SslSniAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SslSniAdd(ctx context.Context, body SslSniAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SslSniDelete request
	SslSniDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SslSniDetail request
	SslSniDetail(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SslSniEditWithBody request with any body
	SslSniEditWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SslSniEdit(ctx context.Context, id string, body SslSniEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CdnList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCdnListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CdnAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCdnAddRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CdnAdd(ctx context.Context, body CdnAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCdnAddRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CdnDelete(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCdnDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CdnDetail(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCdnDetailRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CdnEditWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCdnEditRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CdnEdit(ctx context.Context, id int, body CdnEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCdnEditRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CnameList(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCnameListRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CnameAddWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCnameAddRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CnameAdd(ctx context.Context, id int, body CnameAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCnameAddRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CdnDatacentersList(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCdnDatacentersListRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CdnDatacentersEnableWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCdnDatacentersEnableRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CdnDatacentersEnable(ctx context.Context, id int, body CdnDatacentersEnableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCdnDatacentersEnableRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObjectStorageClusterList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObjectStorageClusterListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObjectStorageStatsWithBody(ctx context.Context, pType ObjectStorageStatsType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObjectStorageStatsRequestWithBody(c.Server, pType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObjectStorageStats(ctx context.Context, pType ObjectStorageStatsType, body ObjectStorageStatsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObjectStorageStatsRequest(c.Server, pType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginAddAwsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginAddAwsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginAddAws(ctx context.Context, body OriginAddAwsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginAddAwsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginDeleteAws(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginDeleteAwsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginDetailAws(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginDetailAwsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginEditAwsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginEditAwsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginEditAws(ctx context.Context, id string, body OriginEditAwsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginEditAwsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginAddObjectStorageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginAddObjectStorageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginAddObjectStorage(ctx context.Context, body OriginAddObjectStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginAddObjectStorageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginDeleteObjectStorage(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginDeleteObjectStorageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginDetailObjectStorage(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginDetailObjectStorageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginEditObjectStorageWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginEditObjectStorageRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginEditObjectStorage(ctx context.Context, id string, body OriginEditObjectStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginEditObjectStorageRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginDeleteStorage(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginDeleteStorageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginDetailStorage(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginDetailStorageRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginEditStorageWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginEditStorageRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginEditStorage(ctx context.Context, id string, body OriginEditStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginEditStorageRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginAddUrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginAddUrlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginAddUrl(ctx context.Context, body OriginAddUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginAddUrlRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginDeleteUrl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginDeleteUrlRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginDetailUrl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginDetailUrlRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginEditUrlWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginEditUrlRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OriginEditUrl(ctx context.Context, id string, body OriginEditUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOriginEditUrlRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SslSniList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSslSniListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SslSniAddWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSslSniAddRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SslSniAdd(ctx context.Context, body SslSniAddJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSslSniAddRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SslSniDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSslSniDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SslSniDetail(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSslSniDetailRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SslSniEditWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSslSniEditRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SslSniEdit(ctx context.Context, id string, body SslSniEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSslSniEditRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCdnListRequest generates requests for CdnList
func NewCdnListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/cdn")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCdnAddRequest calls the generic CdnAdd builder with application/json body
func NewCdnAddRequest(server string, body CdnAddJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCdnAddRequestWithBody(server, "application/json", bodyReader)
}

// NewCdnAddRequestWithBody generates requests for CdnAdd with any type of body
func NewCdnAddRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/cdn")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCdnDeleteRequest generates requests for CdnDelete
func NewCdnDeleteRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/cdn/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCdnDetailRequest generates requests for CdnDetail
func NewCdnDetailRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/cdn/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCdnEditRequest calls the generic CdnEdit builder with application/json body
func NewCdnEditRequest(server string, id int, body CdnEditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCdnEditRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCdnEditRequestWithBody generates requests for CdnEdit with any type of body
func NewCdnEditRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/cdn/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCnameListRequest generates requests for CnameList
func NewCnameListRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/cdn/%s/cname", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCnameAddRequest calls the generic CnameAdd builder with application/json body
func NewCnameAddRequest(server string, id int, body CnameAddJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCnameAddRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCnameAddRequestWithBody generates requests for CnameAdd with any type of body
func NewCnameAddRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/cdn/%s/cname", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCdnDatacentersListRequest generates requests for CdnDatacentersList
func NewCdnDatacentersListRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/cdn/%s/datacenters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCdnDatacentersEnableRequest calls the generic CdnDatacentersEnable builder with application/json body
func NewCdnDatacentersEnableRequest(server string, id int, body CdnDatacentersEnableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCdnDatacentersEnableRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCdnDatacentersEnableRequestWithBody generates requests for CdnDatacentersEnable with any type of body
func NewCdnDatacentersEnableRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/cdn/%s/datacenters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewObjectStorageClusterListRequest generates requests for ObjectStorageClusterList
func NewObjectStorageClusterListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/object-storage/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewObjectStorageStatsRequest calls the generic ObjectStorageStats builder with application/json body
func NewObjectStorageStatsRequest(server string, pType ObjectStorageStatsType, body ObjectStorageStatsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewObjectStorageStatsRequestWithBody(server, pType, "application/json", bodyReader)
}

// NewObjectStorageStatsRequestWithBody generates requests for ObjectStorageStats with any type of body
func NewObjectStorageStatsRequestWithBody(server string, pType ObjectStorageStatsType, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/object-storage/stats/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOriginListRequest generates requests for OriginList
func NewOriginListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOriginAddAwsRequest calls the generic OriginAddAws builder with application/json body
func NewOriginAddAwsRequest(server string, body OriginAddAwsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOriginAddAwsRequestWithBody(server, "application/json", bodyReader)
}

// NewOriginAddAwsRequestWithBody generates requests for OriginAddAws with any type of body
func NewOriginAddAwsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/aws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOriginDeleteAwsRequest generates requests for OriginDeleteAws
func NewOriginDeleteAwsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/aws/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOriginDetailAwsRequest generates requests for OriginDetailAws
func NewOriginDetailAwsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/aws/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOriginEditAwsRequest calls the generic OriginEditAws builder with application/json body
func NewOriginEditAwsRequest(server string, id string, body OriginEditAwsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOriginEditAwsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOriginEditAwsRequestWithBody generates requests for OriginEditAws with any type of body
func NewOriginEditAwsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/aws/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOriginAddObjectStorageRequest calls the generic OriginAddObjectStorage builder with application/json body
func NewOriginAddObjectStorageRequest(server string, body OriginAddObjectStorageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOriginAddObjectStorageRequestWithBody(server, "application/json", bodyReader)
}

// NewOriginAddObjectStorageRequestWithBody generates requests for OriginAddObjectStorage with any type of body
func NewOriginAddObjectStorageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/object-storage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOriginDeleteObjectStorageRequest generates requests for OriginDeleteObjectStorage
func NewOriginDeleteObjectStorageRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/object-storage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOriginDetailObjectStorageRequest generates requests for OriginDetailObjectStorage
func NewOriginDetailObjectStorageRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/object-storage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOriginEditObjectStorageRequest calls the generic OriginEditObjectStorage builder with application/json body
func NewOriginEditObjectStorageRequest(server string, id string, body OriginEditObjectStorageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOriginEditObjectStorageRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOriginEditObjectStorageRequestWithBody generates requests for OriginEditObjectStorage with any type of body
func NewOriginEditObjectStorageRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/object-storage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOriginDeleteStorageRequest generates requests for OriginDeleteStorage
func NewOriginDeleteStorageRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/storage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOriginDetailStorageRequest generates requests for OriginDetailStorage
func NewOriginDetailStorageRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/storage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOriginEditStorageRequest calls the generic OriginEditStorage builder with application/json body
func NewOriginEditStorageRequest(server string, id string, body OriginEditStorageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOriginEditStorageRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOriginEditStorageRequestWithBody generates requests for OriginEditStorage with any type of body
func NewOriginEditStorageRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/storage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOriginAddUrlRequest calls the generic OriginAddUrl builder with application/json body
func NewOriginAddUrlRequest(server string, body OriginAddUrlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOriginAddUrlRequestWithBody(server, "application/json", bodyReader)
}

// NewOriginAddUrlRequestWithBody generates requests for OriginAddUrl with any type of body
func NewOriginAddUrlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/url")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOriginDeleteUrlRequest generates requests for OriginDeleteUrl
func NewOriginDeleteUrlRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/url/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOriginDetailUrlRequest generates requests for OriginDetailUrl
func NewOriginDetailUrlRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/url/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOriginEditUrlRequest calls the generic OriginEditUrl builder with application/json body
func NewOriginEditUrlRequest(server string, id string, body OriginEditUrlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOriginEditUrlRequestWithBody(server, id, "application/json", bodyReader)
}

// NewOriginEditUrlRequestWithBody generates requests for OriginEditUrl with any type of body
func NewOriginEditUrlRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/origin/url/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSslSniListRequest generates requests for SslSniList
func NewSslSniListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/ssl/sni")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSslSniAddRequest calls the generic SslSniAdd builder with application/json body
func NewSslSniAddRequest(server string, body SslSniAddJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSslSniAddRequestWithBody(server, "application/json", bodyReader)
}

// NewSslSniAddRequestWithBody generates requests for SslSniAdd with any type of body
func NewSslSniAddRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/ssl/sni")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSslSniDeleteRequest generates requests for SslSniDelete
func NewSslSniDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/ssl/sni/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSslSniDetailRequest generates requests for SslSniDetail
func NewSslSniDetailRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/ssl/sni/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSslSniEditRequest calls the generic SslSniEdit builder with application/json body
func NewSslSniEditRequest(server string, id string, body SslSniEditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSslSniEditRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSslSniEditRequestWithBody generates requests for SslSniEdit with any type of body
func NewSslSniEditRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v3/ssl/sni/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CdnListWithResponse request
	CdnListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CdnListResponse, error)

	// CdnAddWithBodyWithResponse request with any body
	CdnAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CdnAddResponse, error)

	CdnAddWithResponse(ctx context.Context, body CdnAddJSONRequestBody, reqEditors ...RequestEditorFn) (*CdnAddResponse, error)

	// CdnDeleteWithResponse request
	CdnDeleteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*CdnDeleteResponse, error)

	// CdnDetailWithResponse request
	CdnDetailWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*CdnDetailResponse, error)

	// CdnEditWithBodyWithResponse request with any body
	CdnEditWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CdnEditResponse, error)

	CdnEditWithResponse(ctx context.Context, id int, body CdnEditJSONRequestBody, reqEditors ...RequestEditorFn) (*CdnEditResponse, error)

	// CnameListWithResponse request
	CnameListWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*CnameListResponse, error)

	// CnameAddWithBodyWithResponse request with any body
	CnameAddWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CnameAddResponse, error)

	CnameAddWithResponse(ctx context.Context, id int, body CnameAddJSONRequestBody, reqEditors ...RequestEditorFn) (*CnameAddResponse, error)

	// CdnDatacentersListWithResponse request
	CdnDatacentersListWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*CdnDatacentersListResponse, error)

	// CdnDatacentersEnableWithBodyWithResponse request with any body
	CdnDatacentersEnableWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CdnDatacentersEnableResponse, error)

	CdnDatacentersEnableWithResponse(ctx context.Context, id int, body CdnDatacentersEnableJSONRequestBody, reqEditors ...RequestEditorFn) (*CdnDatacentersEnableResponse, error)

	// ObjectStorageClusterListWithResponse request
	ObjectStorageClusterListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ObjectStorageClusterListResponse, error)

	// ObjectStorageStatsWithBodyWithResponse request with any body
	ObjectStorageStatsWithBodyWithResponse(ctx context.Context, pType ObjectStorageStatsType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObjectStorageStatsResponse, error)

	ObjectStorageStatsWithResponse(ctx context.Context, pType ObjectStorageStatsType, body ObjectStorageStatsJSONRequestBody, reqEditors ...RequestEditorFn) (*ObjectStorageStatsResponse, error)

	// OriginListWithResponse request
	OriginListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OriginListResponse, error)

	// OriginAddAwsWithBodyWithResponse request with any body
	OriginAddAwsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginAddAwsResponse, error)

	OriginAddAwsWithResponse(ctx context.Context, body OriginAddAwsJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginAddAwsResponse, error)

	// OriginDeleteAwsWithResponse request
	OriginDeleteAwsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDeleteAwsResponse, error)

	// OriginDetailAwsWithResponse request
	OriginDetailAwsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDetailAwsResponse, error)

	// OriginEditAwsWithBodyWithResponse request with any body
	OriginEditAwsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginEditAwsResponse, error)

	OriginEditAwsWithResponse(ctx context.Context, id string, body OriginEditAwsJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginEditAwsResponse, error)

	// OriginAddObjectStorageWithBodyWithResponse request with any body
	OriginAddObjectStorageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginAddObjectStorageResponse, error)

	OriginAddObjectStorageWithResponse(ctx context.Context, body OriginAddObjectStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginAddObjectStorageResponse, error)

	// OriginDeleteObjectStorageWithResponse request
	OriginDeleteObjectStorageWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDeleteObjectStorageResponse, error)

	// OriginDetailObjectStorageWithResponse request
	OriginDetailObjectStorageWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDetailObjectStorageResponse, error)

	// OriginEditObjectStorageWithBodyWithResponse request with any body
	OriginEditObjectStorageWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginEditObjectStorageResponse, error)

	OriginEditObjectStorageWithResponse(ctx context.Context, id string, body OriginEditObjectStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginEditObjectStorageResponse, error)

	// OriginDeleteStorageWithResponse request
	OriginDeleteStorageWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDeleteStorageResponse, error)

	// OriginDetailStorageWithResponse request
	OriginDetailStorageWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDetailStorageResponse, error)

	// OriginEditStorageWithBodyWithResponse request with any body
	OriginEditStorageWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginEditStorageResponse, error)

	OriginEditStorageWithResponse(ctx context.Context, id string, body OriginEditStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginEditStorageResponse, error)

	// OriginAddUrlWithBodyWithResponse request with any body
	OriginAddUrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginAddUrlResponse, error)

	OriginAddUrlWithResponse(ctx context.Context, body OriginAddUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginAddUrlResponse, error)

	// OriginDeleteUrlWithResponse request
	OriginDeleteUrlWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDeleteUrlResponse, error)

	// OriginDetailUrlWithResponse request
	OriginDetailUrlWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDetailUrlResponse, error)

	// OriginEditUrlWithBodyWithResponse request with any body
	OriginEditUrlWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginEditUrlResponse, error)

	OriginEditUrlWithResponse(ctx context.Context, id string, body OriginEditUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginEditUrlResponse, error)

	// SslSniListWithResponse request
	SslSniListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SslSniListResponse, error)

	// SslSniAddWithBodyWithResponse request with any body
	SslSniAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SslSniAddResponse, error)

	SslSniAddWithResponse(ctx context.Context, body SslSniAddJSONRequestBody, reqEditors ...RequestEditorFn) (*SslSniAddResponse, error)

	// SslSniDeleteWithResponse request
	SslSniDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SslSniDeleteResponse, error)

	// SslSniDetailWithResponse request
	SslSniDetailWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SslSniDetailResponse, error)

	// SslSniEditWithBodyWithResponse request with any body
	SslSniEditWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SslSniEditResponse, error)

	SslSniEditWithResponse(ctx context.Context, id string, body SslSniEditJSONRequestBody, reqEditors ...RequestEditorFn) (*SslSniEditResponse, error)
}

type CdnListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CdnSummary
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r CdnListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CdnListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CdnAddResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CdnSummary
	JSON422      *FieldErrors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r CdnAddResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CdnAddResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CdnDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r CdnDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CdnDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CdnDetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cdn
	JSON404      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r CdnDetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CdnDetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CdnEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
	JSON422      *FieldErrors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r CdnEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CdnEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CnameListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cnames
	JSON404      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r CnameListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CnameListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CnameAddResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
	JSON422      *FieldErrors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r CnameAddResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CnameAddResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CdnDatacentersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		City *string `json:"city,omitempty"`

		// ContinentCode We recognize 8 continents specified with two letter Continent code.
		ContinentCode *ContinentCode `json:"continent_code,omitempty"`

		// Country Datacenter location country name.
		Country *string `json:"country,omitempty"`

		// IsEnabled Enabled status of the datacenter location.
		IsEnabled *bool    `json:"is_enabled,omitempty"`
		Latitude  *float32 `json:"latitude,omitempty"`

		// LocationId ID of Location. More information in our <a href="/support/api-docs/v3/datacenter">Datacenter</a> API documentation.
		LocationId *string  `json:"location_id,omitempty"`
		Longitude  *float32 `json:"longitude,omitempty"`
	}
	JSON404     *Errors
	JSON422     *FieldErrors
	JSONDefault *Errors
}

// Status returns HTTPResponse.Status
func (r CdnDatacentersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CdnDatacentersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CdnDatacentersEnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r CdnDatacentersEnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CdnDatacentersEnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObjectStorageClusterListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStorageClusters
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r ObjectStorageClusterListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObjectStorageClusterListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObjectStorageStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStorageStatsSet
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r ObjectStorageStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObjectStorageStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OriginList
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginAddAwsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *S3OriginDetail
	JSON422      *FieldErrors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginAddAwsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginAddAwsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginDeleteAwsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
	JSON422      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginDeleteAwsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginDeleteAwsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginDetailAwsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *S3OriginDetail
	JSON404      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginDetailAwsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginDetailAwsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginEditAwsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
	JSON422      *FieldErrors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginEditAwsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginEditAwsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginAddObjectStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStorageOriginDetail
	JSON422      *FieldErrors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginAddObjectStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginAddObjectStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginDeleteObjectStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
	JSON422      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginDeleteObjectStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginDeleteObjectStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginDetailObjectStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStorageOriginDetail
	JSON404      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginDetailObjectStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginDetailObjectStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginEditObjectStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
	JSON422      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginEditObjectStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginEditObjectStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginDeleteStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
}

// Status returns HTTPResponse.Status
func (r OriginDeleteStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginDeleteStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginDetailStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageOriginDetail
	JSON404      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginDetailStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginDetailStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginEditStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
	JSON422      *FieldErrors
}

// Status returns HTTPResponse.Status
func (r OriginEditStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginEditStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginAddUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *UrlOriginDetail
	JSON422      *FieldErrors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginAddUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginAddUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginDeleteUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
	JSON422      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginDeleteUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginDeleteUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginDetailUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UrlOriginDetail
	JSON404      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginDetailUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginDetailUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OriginEditUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
	JSON422      *FieldErrors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r OriginEditUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OriginEditUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SslSniListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslList
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r SslSniListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SslSniListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SslSniAddResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Ssl
	JSON422      *FieldErrors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r SslSniAddResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SslSniAddResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SslSniDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r SslSniDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SslSniDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SslSniDetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ssl
	JSON404      *Errors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r SslSniDetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SslSniDetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SslSniEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ssl
	JSON422      *FieldErrors
	JSONDefault  *Errors
}

// Status returns HTTPResponse.Status
func (r SslSniEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SslSniEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CdnListWithResponse request returning *CdnListResponse
func (c *ClientWithResponses) CdnListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CdnListResponse, error) {
	rsp, err := c.CdnList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCdnListResponse(rsp)
}

// CdnAddWithBodyWithResponse request with arbitrary body returning *CdnAddResponse
func (c *ClientWithResponses) CdnAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CdnAddResponse, error) {
	rsp, err := c.CdnAddWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCdnAddResponse(rsp)
}

func (c *ClientWithResponses) CdnAddWithResponse(ctx context.Context, body CdnAddJSONRequestBody, reqEditors ...RequestEditorFn) (*CdnAddResponse, error) {
	rsp, err := c.CdnAdd(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCdnAddResponse(rsp)
}

// CdnDeleteWithResponse request returning *CdnDeleteResponse
func (c *ClientWithResponses) CdnDeleteWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*CdnDeleteResponse, error) {
	rsp, err := c.CdnDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCdnDeleteResponse(rsp)
}

// CdnDetailWithResponse request returning *CdnDetailResponse
func (c *ClientWithResponses) CdnDetailWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*CdnDetailResponse, error) {
	rsp, err := c.CdnDetail(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCdnDetailResponse(rsp)
}

// CdnEditWithBodyWithResponse request with arbitrary body returning *CdnEditResponse
func (c *ClientWithResponses) CdnEditWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CdnEditResponse, error) {
	rsp, err := c.CdnEditWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCdnEditResponse(rsp)
}

func (c *ClientWithResponses) CdnEditWithResponse(ctx context.Context, id int, body CdnEditJSONRequestBody, reqEditors ...RequestEditorFn) (*CdnEditResponse, error) {
	rsp, err := c.CdnEdit(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCdnEditResponse(rsp)
}

// CnameListWithResponse request returning *CnameListResponse
func (c *ClientWithResponses) CnameListWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*CnameListResponse, error) {
	rsp, err := c.CnameList(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCnameListResponse(rsp)
}

// CnameAddWithBodyWithResponse request with arbitrary body returning *CnameAddResponse
func (c *ClientWithResponses) CnameAddWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CnameAddResponse, error) {
	rsp, err := c.CnameAddWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCnameAddResponse(rsp)
}

func (c *ClientWithResponses) CnameAddWithResponse(ctx context.Context, id int, body CnameAddJSONRequestBody, reqEditors ...RequestEditorFn) (*CnameAddResponse, error) {
	rsp, err := c.CnameAdd(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCnameAddResponse(rsp)
}

// CdnDatacentersListWithResponse request returning *CdnDatacentersListResponse
func (c *ClientWithResponses) CdnDatacentersListWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*CdnDatacentersListResponse, error) {
	rsp, err := c.CdnDatacentersList(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCdnDatacentersListResponse(rsp)
}

// CdnDatacentersEnableWithBodyWithResponse request with arbitrary body returning *CdnDatacentersEnableResponse
func (c *ClientWithResponses) CdnDatacentersEnableWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CdnDatacentersEnableResponse, error) {
	rsp, err := c.CdnDatacentersEnableWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCdnDatacentersEnableResponse(rsp)
}

func (c *ClientWithResponses) CdnDatacentersEnableWithResponse(ctx context.Context, id int, body CdnDatacentersEnableJSONRequestBody, reqEditors ...RequestEditorFn) (*CdnDatacentersEnableResponse, error) {
	rsp, err := c.CdnDatacentersEnable(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCdnDatacentersEnableResponse(rsp)
}

// ObjectStorageClusterListWithResponse request returning *ObjectStorageClusterListResponse
func (c *ClientWithResponses) ObjectStorageClusterListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ObjectStorageClusterListResponse, error) {
	rsp, err := c.ObjectStorageClusterList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObjectStorageClusterListResponse(rsp)
}

// ObjectStorageStatsWithBodyWithResponse request with arbitrary body returning *ObjectStorageStatsResponse
func (c *ClientWithResponses) ObjectStorageStatsWithBodyWithResponse(ctx context.Context, pType ObjectStorageStatsType, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObjectStorageStatsResponse, error) {
	rsp, err := c.ObjectStorageStatsWithBody(ctx, pType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObjectStorageStatsResponse(rsp)
}

func (c *ClientWithResponses) ObjectStorageStatsWithResponse(ctx context.Context, pType ObjectStorageStatsType, body ObjectStorageStatsJSONRequestBody, reqEditors ...RequestEditorFn) (*ObjectStorageStatsResponse, error) {
	rsp, err := c.ObjectStorageStats(ctx, pType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObjectStorageStatsResponse(rsp)
}

// OriginListWithResponse request returning *OriginListResponse
func (c *ClientWithResponses) OriginListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*OriginListResponse, error) {
	rsp, err := c.OriginList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginListResponse(rsp)
}

// OriginAddAwsWithBodyWithResponse request with arbitrary body returning *OriginAddAwsResponse
func (c *ClientWithResponses) OriginAddAwsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginAddAwsResponse, error) {
	rsp, err := c.OriginAddAwsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginAddAwsResponse(rsp)
}

func (c *ClientWithResponses) OriginAddAwsWithResponse(ctx context.Context, body OriginAddAwsJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginAddAwsResponse, error) {
	rsp, err := c.OriginAddAws(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginAddAwsResponse(rsp)
}

// OriginDeleteAwsWithResponse request returning *OriginDeleteAwsResponse
func (c *ClientWithResponses) OriginDeleteAwsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDeleteAwsResponse, error) {
	rsp, err := c.OriginDeleteAws(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginDeleteAwsResponse(rsp)
}

// OriginDetailAwsWithResponse request returning *OriginDetailAwsResponse
func (c *ClientWithResponses) OriginDetailAwsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDetailAwsResponse, error) {
	rsp, err := c.OriginDetailAws(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginDetailAwsResponse(rsp)
}

// OriginEditAwsWithBodyWithResponse request with arbitrary body returning *OriginEditAwsResponse
func (c *ClientWithResponses) OriginEditAwsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginEditAwsResponse, error) {
	rsp, err := c.OriginEditAwsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginEditAwsResponse(rsp)
}

func (c *ClientWithResponses) OriginEditAwsWithResponse(ctx context.Context, id string, body OriginEditAwsJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginEditAwsResponse, error) {
	rsp, err := c.OriginEditAws(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginEditAwsResponse(rsp)
}

// OriginAddObjectStorageWithBodyWithResponse request with arbitrary body returning *OriginAddObjectStorageResponse
func (c *ClientWithResponses) OriginAddObjectStorageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginAddObjectStorageResponse, error) {
	rsp, err := c.OriginAddObjectStorageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginAddObjectStorageResponse(rsp)
}

func (c *ClientWithResponses) OriginAddObjectStorageWithResponse(ctx context.Context, body OriginAddObjectStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginAddObjectStorageResponse, error) {
	rsp, err := c.OriginAddObjectStorage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginAddObjectStorageResponse(rsp)
}

// OriginDeleteObjectStorageWithResponse request returning *OriginDeleteObjectStorageResponse
func (c *ClientWithResponses) OriginDeleteObjectStorageWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDeleteObjectStorageResponse, error) {
	rsp, err := c.OriginDeleteObjectStorage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginDeleteObjectStorageResponse(rsp)
}

// OriginDetailObjectStorageWithResponse request returning *OriginDetailObjectStorageResponse
func (c *ClientWithResponses) OriginDetailObjectStorageWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDetailObjectStorageResponse, error) {
	rsp, err := c.OriginDetailObjectStorage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginDetailObjectStorageResponse(rsp)
}

// OriginEditObjectStorageWithBodyWithResponse request with arbitrary body returning *OriginEditObjectStorageResponse
func (c *ClientWithResponses) OriginEditObjectStorageWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginEditObjectStorageResponse, error) {
	rsp, err := c.OriginEditObjectStorageWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginEditObjectStorageResponse(rsp)
}

func (c *ClientWithResponses) OriginEditObjectStorageWithResponse(ctx context.Context, id string, body OriginEditObjectStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginEditObjectStorageResponse, error) {
	rsp, err := c.OriginEditObjectStorage(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginEditObjectStorageResponse(rsp)
}

// OriginDeleteStorageWithResponse request returning *OriginDeleteStorageResponse
func (c *ClientWithResponses) OriginDeleteStorageWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDeleteStorageResponse, error) {
	rsp, err := c.OriginDeleteStorage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginDeleteStorageResponse(rsp)
}

// OriginDetailStorageWithResponse request returning *OriginDetailStorageResponse
func (c *ClientWithResponses) OriginDetailStorageWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDetailStorageResponse, error) {
	rsp, err := c.OriginDetailStorage(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginDetailStorageResponse(rsp)
}

// OriginEditStorageWithBodyWithResponse request with arbitrary body returning *OriginEditStorageResponse
func (c *ClientWithResponses) OriginEditStorageWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginEditStorageResponse, error) {
	rsp, err := c.OriginEditStorageWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginEditStorageResponse(rsp)
}

func (c *ClientWithResponses) OriginEditStorageWithResponse(ctx context.Context, id string, body OriginEditStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginEditStorageResponse, error) {
	rsp, err := c.OriginEditStorage(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginEditStorageResponse(rsp)
}

// OriginAddUrlWithBodyWithResponse request with arbitrary body returning *OriginAddUrlResponse
func (c *ClientWithResponses) OriginAddUrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginAddUrlResponse, error) {
	rsp, err := c.OriginAddUrlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginAddUrlResponse(rsp)
}

func (c *ClientWithResponses) OriginAddUrlWithResponse(ctx context.Context, body OriginAddUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginAddUrlResponse, error) {
	rsp, err := c.OriginAddUrl(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginAddUrlResponse(rsp)
}

// OriginDeleteUrlWithResponse request returning *OriginDeleteUrlResponse
func (c *ClientWithResponses) OriginDeleteUrlWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDeleteUrlResponse, error) {
	rsp, err := c.OriginDeleteUrl(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginDeleteUrlResponse(rsp)
}

// OriginDetailUrlWithResponse request returning *OriginDetailUrlResponse
func (c *ClientWithResponses) OriginDetailUrlWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*OriginDetailUrlResponse, error) {
	rsp, err := c.OriginDetailUrl(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginDetailUrlResponse(rsp)
}

// OriginEditUrlWithBodyWithResponse request with arbitrary body returning *OriginEditUrlResponse
func (c *ClientWithResponses) OriginEditUrlWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OriginEditUrlResponse, error) {
	rsp, err := c.OriginEditUrlWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginEditUrlResponse(rsp)
}

func (c *ClientWithResponses) OriginEditUrlWithResponse(ctx context.Context, id string, body OriginEditUrlJSONRequestBody, reqEditors ...RequestEditorFn) (*OriginEditUrlResponse, error) {
	rsp, err := c.OriginEditUrl(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOriginEditUrlResponse(rsp)
}

// SslSniListWithResponse request returning *SslSniListResponse
func (c *ClientWithResponses) SslSniListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SslSniListResponse, error) {
	rsp, err := c.SslSniList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSslSniListResponse(rsp)
}

// SslSniAddWithBodyWithResponse request with arbitrary body returning *SslSniAddResponse
func (c *ClientWithResponses) SslSniAddWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SslSniAddResponse, error) {
	rsp, err := c.SslSniAddWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSslSniAddResponse(rsp)
}

func (c *ClientWithResponses) SslSniAddWithResponse(ctx context.Context, body SslSniAddJSONRequestBody, reqEditors ...RequestEditorFn) (*SslSniAddResponse, error) {
	rsp, err := c.SslSniAdd(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSslSniAddResponse(rsp)
}

// SslSniDeleteWithResponse request returning *SslSniDeleteResponse
func (c *ClientWithResponses) SslSniDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SslSniDeleteResponse, error) {
	rsp, err := c.SslSniDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSslSniDeleteResponse(rsp)
}

// SslSniDetailWithResponse request returning *SslSniDetailResponse
func (c *ClientWithResponses) SslSniDetailWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SslSniDetailResponse, error) {
	rsp, err := c.SslSniDetail(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSslSniDetailResponse(rsp)
}

// SslSniEditWithBodyWithResponse request with arbitrary body returning *SslSniEditResponse
func (c *ClientWithResponses) SslSniEditWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SslSniEditResponse, error) {
	rsp, err := c.SslSniEditWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSslSniEditResponse(rsp)
}

func (c *ClientWithResponses) SslSniEditWithResponse(ctx context.Context, id string, body SslSniEditJSONRequestBody, reqEditors ...RequestEditorFn) (*SslSniEditResponse, error) {
	rsp, err := c.SslSniEdit(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSslSniEditResponse(rsp)
}

// ParseCdnListResponse parses an HTTP response from a CdnListWithResponse call
func ParseCdnListResponse(rsp *http.Response) (*CdnListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CdnListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CdnSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCdnAddResponse parses an HTTP response from a CdnAddWithResponse call
func ParseCdnAddResponse(rsp *http.Response) (*CdnAddResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CdnAddResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CdnSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest FieldErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCdnDeleteResponse parses an HTTP response from a CdnDeleteWithResponse call
func ParseCdnDeleteResponse(rsp *http.Response) (*CdnDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CdnDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCdnDetailResponse parses an HTTP response from a CdnDetailWithResponse call
func ParseCdnDetailResponse(rsp *http.Response) (*CdnDetailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CdnDetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cdn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCdnEditResponse parses an HTTP response from a CdnEditWithResponse call
func ParseCdnEditResponse(rsp *http.Response) (*CdnEditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CdnEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest FieldErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCnameListResponse parses an HTTP response from a CnameListWithResponse call
func ParseCnameListResponse(rsp *http.Response) (*CnameListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CnameListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cnames
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCnameAddResponse parses an HTTP response from a CnameAddWithResponse call
func ParseCnameAddResponse(rsp *http.Response) (*CnameAddResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CnameAddResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest FieldErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCdnDatacentersListResponse parses an HTTP response from a CdnDatacentersListWithResponse call
func ParseCdnDatacentersListResponse(rsp *http.Response) (*CdnDatacentersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CdnDatacentersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			City *string `json:"city,omitempty"`

			// ContinentCode We recognize 8 continents specified with two letter Continent code.
			ContinentCode *ContinentCode `json:"continent_code,omitempty"`

			// Country Datacenter location country name.
			Country *string `json:"country,omitempty"`

			// IsEnabled Enabled status of the datacenter location.
			IsEnabled *bool    `json:"is_enabled,omitempty"`
			Latitude  *float32 `json:"latitude,omitempty"`

			// LocationId ID of Location. More information in our <a href="/support/api-docs/v3/datacenter">Datacenter</a> API documentation.
			LocationId *string  `json:"location_id,omitempty"`
			Longitude  *float32 `json:"longitude,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest FieldErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCdnDatacentersEnableResponse parses an HTTP response from a CdnDatacentersEnableWithResponse call
func ParseCdnDatacentersEnableResponse(rsp *http.Response) (*CdnDatacentersEnableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CdnDatacentersEnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseObjectStorageClusterListResponse parses an HTTP response from a ObjectStorageClusterListWithResponse call
func ParseObjectStorageClusterListResponse(rsp *http.Response) (*ObjectStorageClusterListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObjectStorageClusterListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStorageClusters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseObjectStorageStatsResponse parses an HTTP response from a ObjectStorageStatsWithResponse call
func ParseObjectStorageStatsResponse(rsp *http.Response) (*ObjectStorageStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObjectStorageStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStorageStatsSet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginListResponse parses an HTTP response from a OriginListWithResponse call
func ParseOriginListResponse(rsp *http.Response) (*OriginListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OriginList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginAddAwsResponse parses an HTTP response from a OriginAddAwsWithResponse call
func ParseOriginAddAwsResponse(rsp *http.Response) (*OriginAddAwsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginAddAwsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest S3OriginDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest FieldErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginDeleteAwsResponse parses an HTTP response from a OriginDeleteAwsWithResponse call
func ParseOriginDeleteAwsResponse(rsp *http.Response) (*OriginDeleteAwsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginDeleteAwsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginDetailAwsResponse parses an HTTP response from a OriginDetailAwsWithResponse call
func ParseOriginDetailAwsResponse(rsp *http.Response) (*OriginDetailAwsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginDetailAwsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest S3OriginDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginEditAwsResponse parses an HTTP response from a OriginEditAwsWithResponse call
func ParseOriginEditAwsResponse(rsp *http.Response) (*OriginEditAwsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginEditAwsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest FieldErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginAddObjectStorageResponse parses an HTTP response from a OriginAddObjectStorageWithResponse call
func ParseOriginAddObjectStorageResponse(rsp *http.Response) (*OriginAddObjectStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginAddObjectStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStorageOriginDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest FieldErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginDeleteObjectStorageResponse parses an HTTP response from a OriginDeleteObjectStorageWithResponse call
func ParseOriginDeleteObjectStorageResponse(rsp *http.Response) (*OriginDeleteObjectStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginDeleteObjectStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginDetailObjectStorageResponse parses an HTTP response from a OriginDetailObjectStorageWithResponse call
func ParseOriginDetailObjectStorageResponse(rsp *http.Response) (*OriginDetailObjectStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginDetailObjectStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStorageOriginDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginEditObjectStorageResponse parses an HTTP response from a OriginEditObjectStorageWithResponse call
func ParseOriginEditObjectStorageResponse(rsp *http.Response) (*OriginEditObjectStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginEditObjectStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginDeleteStorageResponse parses an HTTP response from a OriginDeleteStorageWithResponse call
func ParseOriginDeleteStorageResponse(rsp *http.Response) (*OriginDeleteStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginDeleteStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOriginDetailStorageResponse parses an HTTP response from a OriginDetailStorageWithResponse call
func ParseOriginDetailStorageResponse(rsp *http.Response) (*OriginDetailStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginDetailStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageOriginDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginEditStorageResponse parses an HTTP response from a OriginEditStorageWithResponse call
func ParseOriginEditStorageResponse(rsp *http.Response) (*OriginEditStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginEditStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest FieldErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOriginAddUrlResponse parses an HTTP response from a OriginAddUrlWithResponse call
func ParseOriginAddUrlResponse(rsp *http.Response) (*OriginAddUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginAddUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UrlOriginDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest FieldErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginDeleteUrlResponse parses an HTTP response from a OriginDeleteUrlWithResponse call
func ParseOriginDeleteUrlResponse(rsp *http.Response) (*OriginDeleteUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginDeleteUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginDetailUrlResponse parses an HTTP response from a OriginDetailUrlWithResponse call
func ParseOriginDetailUrlResponse(rsp *http.Response) (*OriginDetailUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginDetailUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UrlOriginDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOriginEditUrlResponse parses an HTTP response from a OriginEditUrlWithResponse call
func ParseOriginEditUrlResponse(rsp *http.Response) (*OriginEditUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OriginEditUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest FieldErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSslSniListResponse parses an HTTP response from a SslSniListWithResponse call
func ParseSslSniListResponse(rsp *http.Response) (*SslSniListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SslSniListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSslSniAddResponse parses an HTTP response from a SslSniAddWithResponse call
func ParseSslSniAddResponse(rsp *http.Response) (*SslSniAddResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SslSniAddResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Ssl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest FieldErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSslSniDeleteResponse parses an HTTP response from a SslSniDeleteWithResponse call
func ParseSslSniDeleteResponse(rsp *http.Response) (*SslSniDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SslSniDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSslSniDetailResponse parses an HTTP response from a SslSniDetailWithResponse call
func ParseSslSniDetailResponse(rsp *http.Response) (*SslSniDetailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SslSniDetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ssl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSslSniEditResponse parses an HTTP response from a SslSniEditWithResponse call
func ParseSslSniEditResponse(rsp *http.Response) (*SslSniEditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SslSniEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ssl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest FieldErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Errors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
